---
timezone: UTC+8
---

# RonnaldL

**GitHub ID:** z3ro0zy1

**Telegram:** @ronaldl3e

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->
# **实习手册入门导读**

## 1\. Bitcoin入门

### **1.1 Block Header**

**版本号，Previous Blcok Header Hash， 默克尔根，时间戳（Timestamp），难度目标，随机数。、**

**其中，默克尔根是把许多交易浓缩为32字节，方便后续计算Hash。 而对于时间戳来说，从和Gemini的交流中发现，他被允许大于前11个区块的中位数，于是可能会出现Timestamp（N）< Timestamp（N-1）的情况。 这种倒挂是一种逻辑顺序优先的原则。**

**至于难度与随机数**

```
nonce = 0
header_fixed = version + prev_hash + merkle_root + timestamp + nbits  \\ 头信息
while hash(header_fixed + nonce) >= target: \\hash头信息
    nonce += 1
    if nonce > 0xFFFFFFFF:
        # Nonce 溢出了
        update_other_fields()
```

### 1.2 Block Body

Transactions + Signature，还有默克尔树。

比特币的思路和其他新兴公链有极大的类似，因此我认为深度研究BTC技术问题对学习ETH，Solana等有很大帮助。

### 1.3 关于BTC的一些其他问题以及与AI的探讨：

-   **Merkle Tree 到底是怎么把几千笔交易压缩成一个哈希值的？**
    

**最底层：** 对每笔交易(Transaction)进行哈希运算（SHA-256），得到一组哈希值：H1,H2,H3,H4。

**中间层：** 将相邻的两个哈希值拼在一起再哈希。比如：H12=SHA(H1+H2)

**最顶层：** 继续合并。H1234=SHA(H12+H34)。这个最终得到的唯一哈希值就是 **Merkle Root**。

-   **如果两个矿工同时挖出了不同的区块（分叉），网络如何决定听谁的？**
    

**最长链原则，**网络此时一分为二，矿工们会基于自己先收到的那个区块继续挖矿。但是这种竞争通常在下一个区块就会结束。如果基于区块 A 的矿工先挖出了下一个区块C，那么 A + C 这条链就比 B 链长了。 被抛弃的区块 B ，里面原本打包的交易如果没在 A 链中出现，会重新回到内存池等待下次打包。

## 2\. ETH入门

### 2.1 智能合约

上文提到BTC内是纯粹的交易信息，比如Alice给了Bob 100元，这是一种纯粹的金额加减。

而对于ETH的智能合约而言：

它是一段存储在以太坊区块链上的**代码和数据**。

它有自己的地址，但没有私钥，只有代码逻辑。

它平时是静止的。只有当外部账户向它发送一笔交易，或者另一个合约调用它时，它才会执行。

其核心特性：

**不可篡改性**：一旦部署到链上，任何人（包括开发者）都无法修改代码逻辑。

**确定性**：同样的输入，在任何时间、由任何节点运行，结果都必须完全一致。

**自执行性**：不需要中介。如果代码说“周五下午三点把钱转给 A”，那么时间一到，只要有触发条件，钱就会自动转走

### 2.2 以太坊虚拟机EVM，全球统一的引擎

EVM 是一个完全隔离的虚拟环境。合约代码在 EVM 内部运行，无法访问宿主机的文件系统或网络。

这种隔离保证了即使合约有漏洞或恶意代码，也不会拖垮节点电脑。

开发者通常使用 **Solidity** 语言编写合约。但 EVM 听不懂 Solidity，它只能看懂**字节码**。

今天先这样，忙于IELTS考试中 😭
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
