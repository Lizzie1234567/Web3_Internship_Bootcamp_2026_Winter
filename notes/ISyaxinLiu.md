---
timezone: UTC+8
---

# ISyaxinLiu

**GitHub ID:** ISyaxinLiu

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->
第一天打卡：

主要做了三件事：

1.  阅读021 学习以太坊第 1 章 了解了一些关于区块链和以太坊的基本知识
    
2.  听Web3 行业全局介绍 & 岗位概览，了解了大致的岗位以及努力的方向
    
3.  创建了metamask钱包，并第一次领取了活水，也转了一点给同学
    

以下是详细的内容：

## 基本概念

**以太坊（Ethereum）**是一个去中心化、开源并且具备智能合约功能的公共区块链平台。

**智能合约（Smart Contract）** 是一种写在区块链上的自动化协议程序，可以在满足预先设定条件时，自动执行约定好的操作，而不需要人工干预或第三方中介。

**以太坊虚拟机（Ethereum Virtual Machine，EVM）**是以太坊的核心组件，它是

一个图灵完备的虚拟机，能够执行智能合约代码，让区块链不再只是“记账”，而是可以运行各类程序和应用。

**以太（Ether，缩写为 ETH）**加密货币作为其内部交易的“燃料”（Gas），用于支付交易费用和计算服务

**燃料(Gas)** 是以太坊里对“计算工作量”的计价方式，用 ETH 来支付。

**不可替代代币（NFT，Non-Fungible Token）**技术上，NFT是一段写在区块链上的智能合约记录，记录了：

-   唯一编号（Token ID）
    
-   拥有者地址
    
-   相关规则（如转让、版税）
    

**铸造 NFT** \= 把“某个东西的所有权信息”写进区块链，在区块链上创建一个新的、唯一的 NFT

**第 1 步：准备“作品”**

可以是：图片（JPG / PNG）音乐（MP3）视频（MP4）甚至一段文字⚠️ 注意：作品本身一般不直接存到区块链上

**第 2 步：把作品存到“链下**

因为区块链存储很贵，所以通常：上传到 IPFS / Arweave / 云存储得到一个唯一链接（Hash）👉 区块链只保存“指向它的地址”

**第 3 步：创建 NFT 智能合约**

智能合约会规定：NFT 的标准（如 ERC-721 / ERC-1155）每个 NFT 的唯一编号（Token ID）谁是初始拥有者 是否有转售版税

**第 4 步：发起“铸造交易”**

用钱包（如 MetaMask）：调用合约的 mint 函数支付 Gas（用 ETH）这一步是真正上链的关键

**第 5 步：NFT 诞生** 区块链记录：NFT 已存在 Token ID 是多少 拥有者是谁 指向哪份作品 👉 全世界都可以验证

**去中心化金融（DeFi）：**

借贷协议、去中心化交易所、衍生品、稳定币、收益聚合器……

**去中心化自治组织（DAO）：**

规则写进合约，由代币持有者投票治理，无“董事会拍脑袋”。

### 验证者具体在做什么？

以太坊 PoS 中，验证者主要做两件事：

**提议区块（propose）**：某个时隙里会选出一个验证者来打包区块

**证明/投票（attest）**：其他验证者对区块投票确认（证明它有效）

如果验证者：

-   **离线**：会被扣一点收益/罚一点（轻罚，逼你保持在线）
    
-   **作恶（比如双签）**：会触发 **slashing 削减**（重罚，可能损失很大）
    

### 打包区块是什么意思？

“打包区块”就是：把**一堆待处理的交易**（比如转账、调用智能合约）按规则**整理成一个新区块**，并把这个新区块**发布到以太坊链上**，让全网认可它成为“最新一页账本”。

把以太坊想成一本**不断追加的新账本**：

-   **交易** = 一条条记账请求（“A 给 B 转 1 ETH”“我在 Uniswap 换币”）
    
-   **区块** = 一页账本
    
-   **打包区块** = 负责把这一页写好、盖章、交给全网确认的人（PoS 里是“被选中的验证者”）
    

在以太坊 PoS 里，一次“出一个区块”通常是：

-   **1 个验证者被随机选中当“提议者”（proposer）**：负责把交易打包成新区块并发布。
    
-   **很多其他验证者当“证明者/投票者”（attesters）**：对这个区块投票确认它有效。
    

所以是：**1 个负责写这一页账本 + 一群负责盖章确认**。

### 为什么要一群人投票？

因为这样才能做到“去中心化的共识”：

-   如果只有 1 个验证者说了算，他就可能乱写账。
    
-   有很多验证者一起核对投票，作恶更难、成本更高。
    

### 那“最终确认”需要多少验证者？

不需要你记精确数字，只要抓住这个直觉：

-   区块刚出来时，是\*\*“被一批验证者投票支持”\*\*，就算比较稳了（常说的 _finality 之前的确认_）。
    
-   过一段时间，达到协议的最终性（finality）后，区块基本就**不可逆**了——这也依赖**大量验证者的投票**来完成。
    

如果你问的是更直观的问题： **“每个区块是不是只由一个验证者产生？”**——是的，**提议者只有一个**； 但\*\*“每个区块是不是只需要一个验证者认可？”\*\*——不是，**需要很多验证者一起认可**。

## web3交易过程

## 0）你在钱包里点“发送”之前：交易其实是一份“指令包”

一笔以太坊交易本质上包含这些关键信息（你不一定都手填，但钱包都会帮你填）：

-   **from**：你的地址（由签名自动确定）
    
-   **to**：收款地址或合约地址
    
-   **value**：转多少 ETH（如果只是调用合约也可能是 0）
    
-   **data**：调用合约函数时的参数（普通转账通常为空）
    
-   **nonce**：你这个地址发出的第几笔交易（同一地址必须按 nonce 顺序上链）
    
-   **gas limit**：你愿意给这笔交易最多用多少“计算量”
    
-   **费用参数（EIP-1559）**：
    
    -   **maxFeePerGas**：你愿意支付的“每单位 gas 的最高单价”
        
    -   **maxPriorityFeePerGas**：你愿意给打包者的小费（tip）
        
    -   实际上交易要至少覆盖 **base fee + tip**，其中 base fee 会被销毁，tip 给打包者/验证者
        

> 直觉：nonce 决定“排队顺序”，费用决定“别人愿不愿意优先处理你”。

* * *

## 1）签名：你把这份“指令包”变成不可伪造的交易

你点确认后，钱包会用你的私钥对交易签名（不会把私钥发出去）。  
签完以后，这笔交易就有了唯一的 **交易哈希 TxHash**（像收据编号）。

* * *

## 2）广播：交易进入 mempool（交易池）

钱包会把签名后的交易发给一个以太坊节点（可能是你用的钱包/Infura/Alchemy/自建节点）。

节点会先做“基础检查”：

-   签名对不对、nonce 对不对
    
-   你余额是否够支付 `value + 最高可能手续费`
    
-   gas limit、费用参数是否合理（至少有机会覆盖当前 base fee）
    

通过后，它会把交易放进 **mempool**，并转发给其他节点——这时你在浏览器里会看到 **Pending（待打包）**。

* * *

## 3）打包前：谁决定“这笔交易进哪个区块”？

在 PoS 里，以太坊把时间切成：

-   **slot：12 秒一个**
    
-   **epoch：32 个 slot**
    

每个 slot 会随机选出 **1 个验证者当“提议者（proposer）”** 去提出新区块 。

但“新区块里具体放哪些交易、交易怎么排序”在现实里经常是：

-   由提议者自己从 mempool 挑（更简单的情况）
    
-   或者通过“构建者/区块构建市场”拿到一个更赚钱的交易排序方案（你可以先把它理解成：大家都倾向选**手续费更高/更赚钱/更可执行**的交易顺序）
    

所以你**无法在 pending 阶段精确确定**它会进第几个区块，只能用费用等因素提高“尽快进区块”的概率。

* * *

## 4）区块内执行：交易不是“写进去就算完”，还要真正跑一遍

当某个 proposer 把你的交易放进区块后，全网执行层会**按区块里给定的顺序执行交易**：

-   普通转账：扣你余额、加对方余额（固定 21,000 gas）
    
-   调合约：EVM 执行 `data` 里的函数逻辑，读写合约存储、发事件日志等
    
-   如果执行中**触发 revert**：
    
    -   状态改动会回滚
        
    -   **但 gas 仍然消耗**（因为计算已经做了）
        

执行完会生成一份 **receipt（回执）**，里面有：

-   status（成功/失败）
    
-   gasUsed
    
-   logs（事件日志，用于前端/索引器显示“发生了什么”）
    
-   blockNumber、transactionIndex（你最终要找“它在哪个区块”就看这两个）
    

* * *

## 5）确认与“最终性”：什么时候算真的不可逆？

区块提出后，其他验证者会对区块进行投票/证明（attestation），区块就会逐渐“更难被回滚”。

在以太坊当前的 PoS 设计下，通常在**约两个 epoch**后能达到非常强的经济意义上的“最终性（finality）”，也就是大约 **12.8 分钟**（理想网络条件下）。

你在区块浏览器里看到的：

-   **1 confirmation、2 confirmations…**：只是“在它后面又接了多少个区块”，越多越稳
    
-   **finalized**（或类似标记）：基本可以认为不可逆（除非极端大故障/大规模作恶）。
    

## web3技术人员主要工作内容

### 1) 智能合约工程师（Solidity / 协议开发）

-   设计与实现合约：代币、AMM/借贷、NFT、拍卖、治理、权限系统
    
-   写测试、做形式化/模糊测试、Gas 优化
    
-   处理升级（Proxy）、跨链、预言机集成、权限/多签方案
    
-   上线部署与版本管理（主网/测试网、多链）
    

**常见技术栈**

-   语言：**Solidity**（以太坊系主流）、Vyper（少量）
    
-   框架：**Foundry**（forge/cast/anvil）、Hardhat（也很常见）
    
-   合约库：OpenZeppelin、Solmate
    
-   测试：forge test / hardhat test、fuzz（Foundry/Echidna）
    
-   安全工具：Slither、Mythril、Echidna、Manticore（视团队成熟度）
    
-   调试/模拟：Tenderly、anvil/fork、mainnet-fork
    

* * *

### 2) Web3 前端工程师（DApp 前端）

-   做钱包连接、签名、交易发送、状态展示、错误与网络切换
    
-   处理链上数据读取：余额、头寸、NFT、交易历史、价格等
    
-   兼容多钱包/多链，提升交互体验（失败重试、gas 估算、Pending 状态）
    

**常见技术栈**

-   Web：**React / Next.js / TypeScript**
    
-   钱包/链交互：**ethers.js** 或（更现代）**viem + wagmi**
    
-   钱包标准：WalletConnect、EIP-1193 Provider、SIWE（Sign-In with Ethereum）
    
-   UI/状态：TanStack Query、Redux/Zustand（看团队习惯）
    

* * *

### 3) 链下后端 / 区块链基础设施工程师

-   提供 API：用户数据、资产聚合、报价、风控、活动等
    
-   监听链上事件、解析交易，做索引与缓存（否则前端直接读链会很慢/贵）
    
-   管理节点/RPC：自建或对接服务商，做限流、容灾、监控
    
-   处理任务队列：发奖、清算、自动化执行、批处理
    

**常见技术栈**

-   语言：Node.js/TypeScript、Go、Python、Java（都常见）
    
-   数据：Postgres、Redis、Kafka/RabbitMQ
    
-   索引：The Graph（subgraph）、自建 indexer（监听 logs + 解析 ABI）
    
-   存储：IPFS/Arweave（元数据）、对象存储
    
-   云与运维：Docker、K8s、CI/CD、监控告警（Prometheus/Grafana）
    

* * *

### 4) 安全工程师 / 审计方向

-   做威胁建模：重入、权限绕过、价格操纵、闪电贷、MEV 风险
    
-   静态/动态分析、fuzz、形式化验证（成熟团队会做得更深）
    
-   代码审计与上线清单：多签、timelock、权限最小化、应急开关策略
    

**常见技术栈**

-   Slither / Mythril / Echidna / Foundry fuzz
    
-   形式化：Certora / Scribble / K Framework（取决于预算与要求）
    

## 来自群里森理的钱包教程

## MetaMask钱包版

图文教程版：[https://humdrum删-volleyball-4a2删.notion删.site/2e54867ff3e180b5bc84e33a7e2f9835](https://humdrum删-volleyball-4a2删.notion删.site/2e54867ff3e180b5bc84e33a7e2f9835)

省流版：安装MetaMask -> 开启测试网（Google ETH） -> 复制地址领币（俗称领水） -> 转账 -> 拿链接交作业

纯文字版：

在chrome扩展商店搜索MetaMask，安装

安装完毕——创建新钱包——注册

进入钱包

最开始我们是看不到测试网Sepolia的，点击右上角—网络—滑倒最底下，显示测试网络

这时我们的钱包就准备好了

点击收款，复制接收地址（我一般复制Ethereum）

然后去测试网领币（领水）—— [https://cloud删.google删.com/application/web3/faucet/ethereum](https://cloud删.google删.com/application/web3/faucet/ethereum)

选择Ethereum Sepolia（0.05ETH）这一项

粘贴自己的收款地址，ETH到手

然后查看账户，到账了以后就可以打款给别的同学了

选择发送ETH，填入别的同学的钱包地址与发送金额

确认交易，稍等片刻

确认交易完成后点击这个交易

点击在区块浏览器上查看

然后我们就会跳转Etherscan的页面但是不重要

复制顶部的这一串网址，即为我们所需的tx link
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
